<!DOCTYPE html><html>
<head>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,600,700,800' rel='stylesheet' type='text/css'>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<link href="mainstylesheet.css" type="text/css" rel="stylesheet" />

	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="d3.v3.min.js"></script>

	<script type="text/javascript" src="selectbox/jquery.selectbox-0.2.min.js"></script>
	<link href="selectbox/jquery.selectbox.css" type="text/css" rel="stylesheet" />

	<script type="text/javascript" src="jscrollpane/jquery.mousewheel.js"></script>
	<script type="text/javascript" src="jscrollpane/jquery.jscrollpane.min.js"></script>
	<link type="text/css" href="jscrollpane/jquery.jscrollpane.css" rel="stylesheet" media="all" />

	<title>Ripple Live Network</title>
</head>

<body>
<div class="light heading darkgray">Ripple Live Network</div>


<!-- BEGIN VISUALIZATION DIV -->
<div id="visualization" style="position:relative; margin-left: auto; margin-right: auto;" class="fullwidth">

<!-- top bar -->
<input id="focus" class="light rounded topbar" style="left:35px; padding:0 10px; width:295px; height:42px;" type="text"/>
<input id="searchButton" class="topbar" style="left:360px; width:50px; height:50px;" type="button" value="Go" onClick="refocus($('#focus').val(),true);"/>
<div class="topbar" style="left:684px; height:42px; width:230px; outline:none;">
	<select id="currency" onchange="changeCurrency(this.value);">
		<option value="XRP">All Currencies</option>
		<option value="USD">USD - U.S. Dollars</option>
		<option value="EUR">EUR - Euro</option>
		<option value="JPY">JPY - Japanese Yen</option>
		<option value="BTC">BTC - Bitcoins</option>
	</select>
</div>



<!-- begin information below -->
<div id="information" style="opacity:0.8; background-color:#fff; position:absolute; top:701px; left:1.3px; width:905px; height:369px; padding-top:16px;">

<div id="focalAddress" class="light mediumgray large" style="margin-bottom:13px; padding-left:20px;"></div>
<div class="fullwidth topbordered horizontalrule"></div>
<div class="light midsize mediumgray" style="border none; float:left; padding-left:20px;">Balances</div>
<div class="light midsize mediumgray" style="width:44%; border:none; float:right;">History</div>
<div class="clearboth"></div>
<div class="fullwidth bottombordered horizontalrule"></div>

<!-- the table on the left -->
<div class="bottomlist rightbordered" style="width:490px; float:left;">
<div class="scroll-pane" style="height:288px; margin-left:10px;">
	<table style="width:465px; margin-top:4px;" class="outertable" id="balanceTable"></table>
</div></div>


<!-- the table on the right -->
<div class="bottomlist" style="width:410px; float:right;">
<div class="scroll-pane" style="height:288px; margin-right:-22px;">
<table class="rightbordered outertable" style="width:432px;" id="transactionTable">
	<tr class="toprow">
		<td style="width:46px;"><div class="send icon" title="Sent money to...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rUS79pheNhwN6zaqD...</td>
		<td class="marginalcell"/>
	</tr>
	
	<tr>
		<td><div class="receive icon" title="Received money from...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rWWWWWWWWW...</td>
		<td class="marginalcell"/>
	</tr>
	
	<tr>
		<td><div class="receive icon" title="Received money from...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rUS79pheNhwN6zaqD...</td>
		<td class="marginalcell"/>
	</tr>

	<tr>
		<td><div class="receive icon" title="Received money from...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rUS79pheNhwN6zaqD...</td>
		<td class="marginalcell"/>
	</tr>

	<tr>
		<td><div class="receive icon" title="Received money from...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rUS79pheNhwN6zaqD...</td>
		<td class="marginalcell"/>
	</tr>

	<tr>
		<td><div class="receive icon" title="Received money from...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rUS79pheNhwN6zaqD...</td>
		<td class="marginalcell"/>
	</tr>

	<tr>
		<td><div class="receive icon" title="Received money from...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rUS79pheNhwN6zaqD...</td>
		<td/>
	</tr>

	<tr>
		<td><div class="receive icon" title="Received money from...">&nbsp;</div></td>
		<td><span class="bold amount small">1034.24</span> <span class="light small darkgray">USD</span></td>
		<td class="light address right">rUS79pheNhwN6zaqD...</td>
		<td class="marginalcell"/>
	</tr>
</table></div></div>

<div class="clearboth"></div>

</div><!-- end information at the bottom -->

</div><!-- END VISUALIZATION DIV -->

<table id="transactionTable"></table>


<!-- Javascript for the visualization, using the D3 library -->
<script type="text/javascript">

var param = JSON.stringify(window.location.search.replace("?","")).replace(/\W/g, '');

var Options = {
	server: {
		"websocket_ip" : "s1.ripple.com",
		"websocket_port" : 51233,
		"websocket_ssl" : true
	}
};
var RECURSION_DEPTH = 1;
var REFERENCE_NODE = 'rUS79pheNhwN6zaqD3XLiyP6R1jBTwTg4o';//'r3kmLJN5D28dHuH8vZNUZpMC43pEHpaocV';

var COLOR_TABLE = {
//currency  |  center  |   rim  |
	"__Z": [["#dfe0e1","#999999"], //degree 0
/*GRAY*/	["#ebecec","#aaa9a9"], //degree 1
			["#ededee","#bcbbbb"], //etc.
			["#f3f4f4","#d0cece"],
			["#fdfdfe","#e5e4e3"]],
			
	"__N": [["#f05656","#ee2d2c"],
/*RED*/		["#f37a6f","#f16249"],
			["#f6998b","#f5886d"],
			["#fab9ac","#f9ad95"],
			["#fddad1","#fcd4c4"]],
			
	"BTC": [["#e19e41","#b76f2f"],
/*ORANGE*/	["#e5af65","#c38a57"],
			["#e9c189","#d0a57e"],
			["#edd2ad","#dcbfa6"],
			["#f1e4d1","#e9dacd"]],
			
	"JPY": [["#fcf5a1","#fedb3d"],
/*YELLOW*/	["#fdf7b4","#ffe069"],
			["#fdf7c4","#ffe68d"],
			["#fefad8","#ffed83"],
			["#fffcea","#fff5d6"]],
			
	"USD": [["#99cc66","#669940"],
/*LIME*/	["#acd585","#82a85d"],
			["#c0dea1","#9eb880"],
			["#d4e8be","#bbcba4"],
			["#e8f2dd","#dae1cd"]],
			
	"AUD": [["#8dc198","#609869"],
/*GREEN*/	["#a2cbab","#7eab85"],
			["#b7d6bd","#9cbda1"],
			["#cbe0d0","#b9d0bd"],
			["#e0ebe2","#d7e2d9"]],
			
	"XRP": [["#55a7cc","#346aa9"],
/*BLUE*/	["#83b8d6","#5083b9"],
			["#a7cae1","#7ba1cb"],
			["#d0e1ed","#a3c2dd"],
			["#f2f6fa","#cee8f1"]],
			
	"___": [["#6566ae","#363795"], //I.e., any other currency.
/*INDIGO*/	["#7e7cbb","#5855a5"],
			["#9896c9","#7a74b6"],
			["#b6b4da","#9e99cb"],
			["#d7d6eb","#c9c6e3"]],
			
	"CAD": [["#8e68ad","#673695"],
/*VIOLET*/	["#9f80ba","#7d58a5"],
			["#8e68ad","#673695"],
			["#c8b8da","#b29ecc"],
			["#e0d8eb","#d4cae4"]],
			
	"EUR": [["#b76e99","#863d66"],
/*PINK*/	["#c389ab","#9c6283"],
			["#d0a4be","#b2879f"],
			["#dcbfd0","#c9abbc"],
			["#d9dae3","#dfd0d8"]]};
			



if (param == "") {
	var focalNode = REFERENCE_NODE;
} else {
	var focalNode = param;
}

var lastFocalNode = REFERENCE_NODE;
var currentCurrency = "XRP";
var w = 935;  //Width
var h = 1085; //Height
var hh = 710; //Height above the bottom bar

var nodes = [ {x:w/2, y:hh/2, account:{Account:focalNode, Balance:0}, trustLines:[], balances:{} }];
var le_links = [];
var nodeMap = {};
nodeMap[focalNode] = 0;
var degreeMap = {};
degreeMap[focalNode] = 0;

var server = {};
server.socket = null; 	
var str;
if (Options.server.websocket_ssl) {
	str= "wss://" + Options.server.websocket_ip + ":";
} else {
	str= "ws://" + Options.server.websocket_ip + ":";
}
str += Options.server.websocket_port;
str += "/";
server.socket = new WebSocket(str);
var expandedNodes = {};

server.socket.onopen = function() { //Set up the connection and subscribe to the appropriate streams.
	/* //TODO: Update the graph in real time as data comes in from the streams.
	var command = '{"command":"ledger", "ledger": "closed" , "full" : 1 }';
	server.socket.send(command);
	command = '{"command":"subscribe", "streams" : [ "transactions" ]}';
	server.socket.send(command);
	*/
	serverGetInfo(focalNode);
	expandNode(focalNode);
	lastFocalNode = REFERENCE_NODE;
	addNodes(0);
};

server.socket.onmessage = function(msg) { //Process a message received from Ripple.
	var obj = jQuery.parseJSON(msg.data);
	if (obj && obj.result && obj.result.lines) {
		addConnections(obj.result.account, obj.result.lines);
	} else if(obj.transaction) {
		//TODO: Visualize the transaction.
	} else if (obj && obj.result && obj.result.account_data) {
		if ($.isEmptyObject(obj.result.account_data)) {
			alert("This address is not valid!");
			console.log(obj);
			refocus(lastFocalNode,true);
		} else {
			var n = nodes[nodeMap[obj.result.account_data.Account]];
			n.account = obj.result.account_data;
			if (currentCurrency == "XRP") { // Change the size of the circles, and recalculate the arrows.
				updated = svg.select("g#nodeGroup").select("circle#"+obj.result.account_data.Account);
				updated.attr("r", nodeRadius(n));
				updateAllArrows();
			}
			if (obj.result.account_data.Account == focalNode) {
				//Update the XRP listing on the table below. (But don't rewrite the whole table, because that's excessive.)
				$("#xrpBalance").text(commas(n.account.Balance/1000000));
			}
		}
	} else if (obj && obj.result && obj.result.transactions) {
		var n = nodes[nodeMap[obj.result.account]];
		n.transactions = obj.result.transactions;
		if (obj.result.account == focalNode) {
			updateTransactions(focalNode);
		}
	} else {
		console.log("Could not interpret message.");
		console.log(obj);
	}
};

server.socket.onclose = function() {
	console.log("disconnected from websocket");
} 


function calculateArrows(d) {
	var rr = Math.ceil(5+nodeRadius(d.target));
	return "url(\#arrow"+Math.min(59,rr)+")";
}

function updateAllArrows() {
	svg.select("g#linkGroup").selectAll("line").attr("marker-end", calculateArrows);
}


function currentCurrencyBalance(accountNode) {
	var output;
	if (currentCurrency == "XRP") {
		output = accountNode.account.Balance;
	} else {
		output = accountNode.balances[currentCurrency];
		if (!output) { output = 0; }
	}
	return output;
}

function addConnections(origin, trustLines) {
	//Receive an array of the format:
	//[{"account":"rnziParaNb8nsU4aruQdwYE3j5jUcqjzFm","balance":"0","currency":"BTC","limit":"0","limit_peer":"0.25","quality_in":0,"quality_out":0},
	//{"account":"rU5KBPzSyPycRVW1HdgCKjYpU6W9PKQdE8","balance":"0","currency":"BTC","limit":"0","limit_peer":"10","quality_in":0,"quality_out":0}]
	
	nodes[nodeMap[origin]].trustLines = trustLines;
	nodes[nodeMap[origin]].balances = getBalances(origin);

	if (origin == focalNode) {
		updateInformation(origin);
	}
	
	if (currentCurrency != "XRP") { // Change the size of the circle, if we needed to wait until now to figure out its balance (i.e. we're looking at a currency other than XRP.)
		svg.select("g#nodeGroup")
			.select("circle#"+origin)
			.attr("r", nodeRadius(nodes[nodeMap[origin]]) );
		updateAllArrows();
	}
	
	if (degreeMap[origin] < RECURSION_DEPTH) {
		expandedNodes[origin] = true;
		var newNodes = [];
		var newLinks = [];
		for (var i=0; i<trustLines.length; i++) {
			// add trustLines[i]["account"] to the list of nodes, if it's not on it already.
			// add a link from the current node to trustLines[i]["account"], if it's not there already.
			trustLine = trustLines[i];
			account = trustLine["account"];
			// Fetch the node corresponding to the counterparty of this trust line,
			// or if it's not on the list yet, create one and add it to the list.
			if ("undefined" == typeof nodeMap[account]) {
				if (parseFloat(trustLine.limit) != 0.0 ||  parseFloat(trustLine.limit_peer) != 0.0) {
					nodeMap[account]=nodes.length;
					degreeMap[account] = degreeMap[origin] + 1;
					var angle = Math.random() * 6.283185307179586;
					var radius= Math.random() * 100;
					var node = {
						x:nodes[nodeMap[origin]].x+Math.cos(angle)*radius,
						y:nodes[nodeMap[origin]].y+Math.sin(angle)*radius,
						account: {
							Account:account,
							Balance:"0",
						},
						trustLines: [],
						balances: {}
					}
					newNodes.push(node);
					nodes.push(node);
				}
				degreeMap[account] = degreeMap[origin] + 1; 
				serverGetInfo(account); //If this node is not on the list yet, we're going to need to get the info and trustLines for it.
				serverGetLines(account);
			} else {
				var node = nodes[nodeMap[account]];
			}
			// Now, create links to all of the counterparties that have not been expanded (ie., had their links displayed.)
			if (expandedNodes[account]) {} else {
				var link={};
				function goon(link) {
					if (parseFloat(trustLine.limit) != 0.0 && parseFloat(trustLine.limit_peer) != 0.0) {
						link.strength = 0.5;
					} else {
						link.strength = 1;
					}
					link.currency=trustLines[i].currency;
					le_links.push(link);
				}
				if (parseFloat(trustLine.limit) != 0.0) {
					link.source=nodes[nodeMap[ origin ]];
					link.target=node;
					link.value= parseFloat(trustLine.limit);
					goon(link);
				}
				if (parseFloat(trustLine.limit_peer) != 0.0) {
					var link={};
					link.target=nodes[nodeMap[ origin ]];
					link.source=node;
					link.value= parseFloat(trustLine.limit_peer);
					goon(link);
				}

			}
		}
	}
	
	reassignColors(origin);
	addNodes(degreeMap[origin]+1);
}


function serverGetLines(address) {
	if ($.isEmptyObject(nodes[nodeMap[address]].trustLines)) {
		command= '{"command":"account_lines", "account":"'+address+'"}';
		server.socket.send(command);
	} else {
		addConnections(address, nodes[nodeMap[address]].trustLines);
	}
}
function serverGetInfo(address) {
	if (nodes[nodeMap[address]].account.index) {
		// Don't do anything if we already have information about this account.
		// TODO: Why does this never happen?
	} else {
		command = '{"command":"account_info", "ident":"'+address+'"}'; 
		server.socket.send(command);
		command = '{"command":"ledger", "ledger_selector":"current"}';
		server.socket.send(command);
		command = '{"command":"account_tx", "account":"'+address+'", "ledger_min":"'+1+'", "ledger_max":"'+210602+'"}'; 
		server.socket.send(command);
		
	}
}

var svg = d3.select("#visualization")
	.append("svg:svg")
	.attr("width", w)
	.attr("height", h).attr("pointer-events", "all")
	.style("background-color", "#fff").on("click",function(){
		if($('.sbOptions').css("display") == "block") {
			$('.sbToggle').trigger('click');
		}
	})
	.style("float","left").style("border", "1px solid #c8c8c8")
	.style("margin-right","10").call(d3.behavior.zoom({
        dblclick: false,
        wheel: false
    }).on("zoom", redraw)).on("mousewheel.zoom",null).on("dblclick.zoom",null);

/*TODO: Fix this bug in Firefox, where the graph pans strangely when you scroll the mouse wheel. (It should do nothing.)*/
var lastD3ZoomEvent = {scale:1, translate:[0,0]};
var firefoxOffset = [0,0];
function redraw() {
	var translation = d3.event.translate;
	if (d3.event.scale == lastD3ZoomEvent.scale) {
		var tx = translation[0] - firefoxOffset[0];
		var ty = translation[1] - firefoxOffset[1];
		linkGroup.attr("transform","translate(" + [tx,ty] + ")");
		nodeGroup.attr("transform","translate(" + [tx,ty] + ")");
	} else {
		firefoxOffset = [firefoxOffset[0] + (d3.event.translate[0] - lastD3ZoomEvent.translate[0]), (firefoxOffset[1] + d3.event.translate[1] - lastD3ZoomEvent.translate[1])];
	}
	lastD3ZoomEvent = jQuery.extend(true, {}, d3.event);
}	

var defs = svg.append("defs");

function defineRadialGradient(name, innerColor, outerColor) {
	var radGrad = defs.append("radialGradient")
		.attr("id", name)
		.attr("fx", "50%")
		.attr("fy", "50%")
		.attr("r", "100%")
		.attr("spreadMethod", "pad");
	radGrad.append("stop")
		.attr("offset","0%")
		.attr("stop-color",innerColor)
		.attr("stop-opacity","1");
	radGrad.append("stop")
		.attr("offset","100%")
		.attr("stop-color",outerColor)
		.attr("stop-opacity","1");
}
for (var cur in COLOR_TABLE) {	
	var shades = COLOR_TABLE[cur];
	for (var i=0; i<shades.length; i++) {
		defineRadialGradient("gradient"+cur+i, shades[i][0], shades[i][1]);
	}
}



for (var i=0; i<60; i++) {
defs.append("svg:marker")
	.attr("id", "arrow"+(i))
	.attr("viewBox", "0 0 10 10")
	.attr("refX", i)
	.attr("refY", 5)
	.style("fill","#2d466e")
	.attr("markerWidth", 16)
	.attr("markerHeight", 12)
	.attr("orient", "auto")
	.append("svg:path")
	.attr("d", "M 0 0 L 10 5 L 0 10 z");
}

var linkGroup = svg.append("g").attr("id","linkGroup");
var nodeGroup = svg.append("g").attr("id","nodeGroup");

function nodeRadius(accountNode) {
	var bal = currentCurrencyBalance(accountNode);
	if (currentCurrency != "XRP") {
		bal = bal * 1000000000;
	} 
	return 14+Math.pow(Math.log(Math.abs(bal)+1),3) / 2000;
}

var force = d3.layout.force()
	.size([w, 710])
	.linkDistance(80)
	.linkStrength(function(d) {
		if (currentCurrency == "XRP" || currentCurrency == d.currency) {
			return d.strength * 0.25;
		} else {
			return 0;
		}
	}).friction(0.5)
	.charge(-1500).nodes([]).links([]).start();

function expandNode(address) {
	lastFocalNode = focalNode;
	focalNode = address;
	if ("undefined" == typeof nodeMap[address]) {
		refocus(address, false);
	} else {
		degreeMap = {};
		degreeMap[address] = 0;
		reassignColors(address);
		if (expandedNodes[address]) {} else {
			serverGetLines(address);
		}
		updateInformation(address);
	}
}


function borderColor(cur, colorDegree) {
	if (colorDegree == 0) {
		return "#fc0"; //It actually doesn't use the border color for the focal node.
	} else {
		return COLOR_TABLE[cur][colorDegree-1][1]; //Use the rim color of the next darkest degree.
	}
}


function findCur(d) {
	var cur = currentCurrency;
	if(cur != "XRP") {
		if(!d.balances[cur]){cur="__Z";}
		else if(d.balances[cur]<0){cur="__N";}
		else if(!COLOR_TABLE.hasOwnProperty(cur)) {cur = "___";}
	}
	return cur;
}

function lightenNodeFunction(colorDegree) {
	return function(d) {
		var cur = findCur(d);
		d3.select(d3.event.target).style("fill", "url(#gradient"+cur+(colorDegree+1)+")");
	}
}
function darkenNodeFunction(colorDegree) {
	return function(d) {
		var cur = findCur(d);
		d3.select(d3.event.target).style("fill", "url(#gradient"+cur+(colorDegree)+")");
	}
}
function lightenAddress(address) {
	var colorDegree = Math.min(degreeMap[address], 3);
	var cur = findCur(force.nodes()[nodeMap[address]]);
	nodeGroup.select("#"+address).style("fill", "url(#gradient"+cur+(colorDegree+1)+")");
}
function darkenAddress(address) {
	var colorDegree = Math.min(degreeMap[address], 3);
	var cur = findCur(force.nodes()[nodeMap[address]]);
	nodeGroup.select("#"+address).style("fill", "url(#gradient"+cur+(colorDegree)+")");
}



function colorNodes(nodeSelection, colorDegree) {
	nodeSelection.style("fill", function(d) { 
			var cur = findCur(d);
			return ("url(#gradient"+cur+colorDegree+")");
		})
		.style("stroke", function(d){var cur = findCur(d); return borderColor(cur,colorDegree);} )
		.style("stroke-width", 0.5)
		.on("mouseover", lightenNodeFunction(colorDegree))
		.on("mouseout", darkenNodeFunction(colorDegree));
	if (colorDegree == 0) {
		nodeSelection.style("stroke-width", 5);
	}
}


function reassignColors(address) {
	var colorDegree = Math.min(degreeMap[address], 3);
	colorNodes(svg.select("g#nodeGroup").select("circle#"+address), colorDegree)
	
	function goon(counterparty) { // ...then reassign the colors of each counterparty too,
		//only if the new degree is lower than the previous one (or the degree is as yet unknown)
		if (typeof degreeMap[counterparty] == "undefined" || degreeMap[counterparty] > degreeMap[address]+1) {
			degreeMap[counterparty] = degreeMap[address]+1;
			reassignColors(counterparty);
		}
	}
	for (var i=0; i<le_links.length; i++) {
		var link = le_links[i];
		if (link.source.account.Account == address) { // If this address is party to the link...
			goon(link.target.account.Account);
		} else if (link.target.account.Account == address) {
			goon(link.source.account.Account);
		}
	}
}

function colorRogueNodes() {
	//TODO
}





function addNodes(degree) {

	force.nodes(nodes).links(le_links);
	var timer;
	var colorDegree = Math.min(degree, 3);
	var node = svg.select("g#nodeGroup").selectAll("circle.node").data(nodes)
		.enter().append("svg:circle")
		.attr("class", "node")
		.attr("id", function(d) { return d.account.Account;})
		.attr("cx", function(d) { return d.x; })
		.attr("cy", function(d) { return d.y; })
		.attr("r", nodeRadius )
		.attr("title", function(d) { return d.account.Account; })
		.style("cursor", "pointer")
		.on("click", function(d) { force.stop(); expandNode(d.account.Account); setTimeout(force.resume,500); } );
	colorNodes(node, colorDegree);
	node.append("svg:title").text( function(d) { return d.account.Account;} );
	node.call(force.drag);
	

	var link = svg.select("g#linkGroup").selectAll("line").data(force.links())
		.enter().append("svg:line")
		.style("stroke","#2d2d2d")
		.attr("stroke-width", linkOrNot)
		.attr("marker-end", calculateArrows);
		
	force.start();
  

	var node = svg.selectAll("circle.node");
	var link = svg.selectAll("line");
	
	force.on("tick", function(e) {
		node.attr("cx", function(d) { return d.x; })
			.attr("cy", function(d) { return d.y; });
		link.attr("x1", function(d) {return d.source.x;})
			.attr("y1", function(d) {return d.source.y;})
			.attr("x2", function(d) {return d.target.x;})
			.attr("y2", function(d) {return d.target.y;})
	});
}

function refocus(focus, erase) {
	if (erase) {
		svg.select("g#nodeGroup").selectAll("circle.node").data([]).exit().remove();
		svg.select("g#linkGroup").selectAll("line")       .data([]).exit().remove();
		nodes = [];
		le_links = [];
		nodeMap = {};
		expandedNodes = {};
	}
	lastFocalNode = focalNode;
	focalNode = focus;
	nodeMap[focalNode] = nodes.length;
	nodes.push({x:0.5*w, y:hh/2, account:{Account:focalNode, Balance:0}, trustLines:[], balances:{} });
	degreeMap = {};
	degreeMap[focalNode] = 0;
	serverGetLines(focalNode);
	addNodes(0);
	reassignColors(focalNode);
	serverGetInfo(focalNode);
	updateInformation(focus);
}



function commas(number) {
    var parts = number.toString().split(".");
    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	if (parts[1] && parts[1].length>5) {parts[1] = parts[1].slice(0,5)};
    return parts.join(".");
}

function abbreviate(address) {
	return address.slice(0,25)+"...";
}

function updateInformation(address) {
	$('#focus').val(address);
	$('#focalAddress').text(address);

	var currencies = [];
	var balances = getBalances(address);
	for (var cur in balances) {
		currencies.push(cur);
	}
	currencies.sort(function(a,b){return (Math.abs(balances[b])-Math.abs(balances[a]))});
	
	var trustLines = nodes[nodeMap[address]].trustLines;
	if (!trustLines) {
		trustLines = [];
	}

	$('#balanceTable').text("");
	$('#balanceTable').append(
		'<tr class="toprow">'+
			'<td class="circlecell"><svg width="22" height="22">'+
				'<circle cx="11" cy="11" r="11" style="fill:'+COLOR_TABLE['XRP'][0][1]+';"></circle>'+
			'</svg></td>'+
			'<td class="light small mediumgray" style="width:35px;">XRP</td>'+
			'<td class="bold amount" id="xrpBalance">'+commas(nodes[nodeMap[address]].account.Balance/1000000)+'</td>'+
			'<td class="light expander">&nbsp;</td>'+
		'</tr>');
	
	for (var i=0; i<currencies.length; i++) {
		var cur = currencies[i];
		var trustLinesForCur = [];
		for (var j=0; j<trustLines.length; j++) {
			var trustLine = trustLines[j];
			if (trustLine.currency == cur) {
				trustLinesForCur.push(trustLine);
			}
		}
		trustLinesForCur.sort(function(a,b){return Math.abs(b.balance)-Math.abs(a.balance);});
		$('#balanceTable').append(
			'<tr style="cursor:'+(trustLinesForCur.length ? 'pointer' : 'auto')+'" sublistid="'+cur+
					'" numberofsubrows="'+trustLinesForCur.length+'" '+
					'onclick="'+(trustLinesForCur.length ? 'toggleExpansion(this)' : '')+'">'+
				'<td class="circlecell"><svg width="22" height="22">'+
					'<circle cx="11" cy="11" r="11" style="fill:'+COLOR_TABLE[(COLOR_TABLE.hasOwnProperty(cur)?cur:'___')][0][1]+';"></circle>'+
				'</svg></td>'+
				'<td class="light small mediumgray">'+cur+'</td>'+
				'<td class="bold amount">'+commas(balances[cur])+'</td>'+
				'<td class="light expander">'+(trustLinesForCur.length ? '<span id="'+cur+'Expander">+</span></td>' : '&nbsp;')+
			'</tr>');
			
		if (trustLinesForCur.length) {
			$('#balanceTable').append(
				'<tr class="innertablecontainer" id="'+cur+'">'+
				'<td colspan=4>'+
				'<div id="'+cur+'Inner">'+
				'<table class="innertable" style="table-layout:fixed;" id="'+cur+'InnerTable">'+
				'</table></div></td></tr>');
			$('#'+cur+'InnerTable').append(
				'<tr>'+
					'<th class="bold midsize" style="font-weight:bold; width:50%;">Address</th>'+
					'<td class="bold midsize" style="width:16%;">Min</td>'+
					'<td class="bold midsize center" style="width:16%">Balance</td>'+
					'<td class="bold midsize right" style="width:16%;">Max</td>'+
				'</tr>');
			for (var j=0; j<trustLinesForCur.length; j++) {
				var tl = trustLinesForCur[j];
				$('#'+cur+'InnerTable').append(
					'<tr>'+
						'<th class="light address"><span style="cursor:pointer;" '+
							'onmouseover="lightenAddress(\''+tl.account+'\');"'+
							'onmouseout="darkenAddress(\''+tl.account+'\');"'+
							'onclick="expandNode(\''+tl.account+'\');">'+
							abbreviate(tl.account)+'</span></th>'+
						'<td class="light '+(tl.limit_peer>0 ? 'negative ' : '')+'amount">'+commas(-1*tl.limit_peer)+'</td>'+
						'<td style="width:37px;" class="bold '+(tl.balance<0 ? 'negative ' : '')+'amount center">'+commas(tl.balance)+'</td>'+
						'<td style="width:37px;" class="light '+(tl.limit<0 ? 'negative ' : '')+'amount right">'+commas(tl.limit)+'</td>'+
					'</tr>');
			}		
		}
	}
	updateTransactions(address);
}

function updateTransactions(address) {
	$('#transactionTable').text("");
	if (nodes[nodeMap[address]].transactions) {
		for (var i=0; i<nodes[nodeMap[address]].transactions.length; i++) {
			var tx = nodes[nodeMap[address]].transactions[i].tx;
			var transactionType;
			var counterparty;
			var amount;
			var currency;
			
			if (tx.TransactionType == "Payment") {
				amount = tx.Amount;
				if (tx.Account == address) {
					transactionType = "send";
					counterparty = tx.Destination;
				}
				else if (tx.Destination == address) {
					transactionType = "receive";
					counterparty = tx.Account;
				} else {continue;}
			} else if (tx.TransactionType == "TrustSet") {
				amount = tx.LimitAmount;
				if (tx.Account == address) {
					transactionType = "trustout";
					counterparty = tx.LimitAmount.issuer;
				}
				else if (tx.LimitAmount.issuer == address) {
					transactionType = "trustin";
					counterparty = tx.Account;
				} else {continue;}
			} else if (tx.TransactionType == "OfferCreate") { continue;
			} else if (tx.TransactionType == "OfferCancel") { continue;
			} else {continue;}
			
			if (amount.currency) {
				currency = amount.currency;
				amount = amount.value;
			} else {
				currency = "XRP";
			}
			
			$('#transactionTable').append(
				'<tr>'+
					'<td style="width:46px;"><div class="'+transactionType+' icon" title="'+transactionType+'">&nbsp;</div></td>'+
					'<td><span class="bold amount small">'+commas(amount)+'</span> <span class="light small darkgray">'+currency+'</span></td>'+
					'<td class="light address right"><span style="cursor:pointer;" '+
							'onmouseover="lightenAddress(\''+counterparty+'\');"'+
							'onmouseout="darkenAddress(\''+counterparty+'\');"'+
							'onclick="expandNode(\''+counterparty+'\');">'+
							abbreviate(counterparty)+'</span></td>'+
					'<td class="marginalcell"/>'+
				'</tr>');
		}
	}
}


function getBalances(address) {
	var balances = {};
	if (nodes[nodeMap[address]].trustLines) {
		for (var i=0; i<nodes[nodeMap[address]].trustLines.length; i++) {
			var trustLine = nodes[nodeMap[address]].trustLines[i];
			if (balances[trustLine.currency]) {
				balances[trustLine.currency] += parseFloat(trustLine.balance);
			} else {
				balances[trustLine.currency] = parseFloat(trustLine.balance);
			}
		}
	}
	return balances;
}

function linkOrNot(d) {
	if(currentCurrency=="XRP" || currentCurrency==d.currency) {return 1;} 
	else{return 0;}
}

function changeCurrency(newCurrency) {
	currentCurrency = newCurrency;
	degreeMap = {};
	degreeMap[focalNode] = 0;
	reassignColors(focalNode);
	updated = svg.select("g#nodeGroup").selectAll("circle");
	updated.attr("r", nodeRadius );
	svg.select("g#linkGroup").selectAll("line").attr("stroke-width", linkOrNot);
	updateAllArrows();
	force.start();
}

function toggleExpansion(row) {
	var cur = row.getAttribute("sublistid");
	var numberOfSubrows = parseInt(row.getAttribute("numberofsubrows"));
	var expander = document.getElementById(cur+"Expander");
	if (expander.innerHTML == "+") {
		$('#'+cur+'Inner').animate({height:(11+(numberOfSubrows+1)*25.5)+'px'});
				$('#'+cur).show()
		expander.innerHTML = "&ndash;";
	} else {
		$('#'+cur+'Inner').animate({height:'0px'}, {complete: function(){$('#'+cur).hide();} });
		expander.innerHTML = "+";
	}
}


</script>


<!-- Initialization functions -->
<script>
	$(function () {$('.scroll-pane').jScrollPane({autoReinitialise: true, hideFocus: true});});
	$(function () {$("#currency").selectbox();});
	$("#focus").keyup(function(event){
		if(event.keyCode == 13){
			$("#searchButton").click();
		}
	});
	updateInformation(focalNode);
	
</script>



</body>
</html>